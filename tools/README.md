# ICON4Py Tools

## Description

Tools and utilities for integrating icon4py code into the ICON model.

## Installation instructions

Until development reaches a stable state, we recommend that you follow the general instructions in the [../README.md](../README.md) root folder to install `icon4py.tools` and all of its dependencies in a virtual environment.

## Command-line tools


# py2fgen

`py2fgen` is a command-line interface (CLI) tool designed to generate C and Fortran 90 (F90) wrappers, as well as a C library, for embedding a Python module into C and Fortran applications. This tool facilitates the embedding of Python code into Fortran programs by utilizing the [`CFFI`](https://cffi.readthedocs.io/en/latest/embedding) library. `CFFI` instantiates a Python interpreter to execute Python code which is "frozen" into the dynamic library generated by `CFFI`.

**Note:** `py2fgen` has been used to embed the diffusion and dycore granule into ICON. It is important to remember that there are performance implications related to converting Fortran pointers to array-like objects that can be used in Python. It is also important to note that functions embedded into Fortran can only accept arguments with intrinsic types, as well as arrays. It is currently not possible to pass derived types to embedded Python functions.

## Usage

`py2fgen` simplifies the process of embedding Python functions into C and Fortran codebases. Here's how to use it:

```bash
py2fgen [OPTIONS] MODULE_IMPORT_PATH FUNCTION_NAME

Arguments:
  MODULE_IMPORT_PATH  The Python module import path to the module where the functions to be embedded are defined.
  FUNCTIONS           A comma-separated list of functions to be embedded in the case of multiple, otherwise just the function name.
  PLUGIN_NAME         The name of the plugin used for creating the shared library and bindings.
Options:
  -o, --output-path PATH          Specify the directory for generated code and
                                  compiled libraries.
  -b, --backend [CPU|GPU|ROUNDTRIP]
                                  Set the backend to use, thereby unpacking
                                  Fortran pointers into NumPy or CuPy arrays
                                  respectively.
  -d, --debug-mode                Enable debug mode to log additional Python
                                  runtime information.
  -p, --profile                   Profile granule runtime and unpacking
                                  Fortran pointers into NumPy or CuPy arrays.
  --limited-area                  Enable limited area mode.
```

## Initialising the grid

When embedding granules it may be necessary to have access to the representation of the ICON grid inside the granule. In order to initialise the grid for each granule there exists a `grid_init_<granule_name>` function which must also be embedded and called from Fortran. Each granule has access to a module state which is defined in a dictionary at the top of the module, for example `diffusion_wrapper_state` in the diffusion wrapper.

## Environment variables

In order to run the embedded code from Fortran it is necessary to set environment variables based on whether you are running in a CPU or GPU context. For more information on these, as well as other information on how to build and integrate embedded code into ICON using py2fgen see [this document](https://hackmd.io/OmmNptDRTe2lex7GXuYDIQ#Python-Granule-Integration-into-ICON).

### Example

To create a Fortran interface along with the dynamic library for a Python function named `square` within the module `example.functions`, execute:

```bash
py2fgen example.functions square
```

It is also possible to generate bindings for more than one function at a time by using a comma-separated list of function names:

```bash
py2fgen example.functions square,square2
```

`py2fgen` can accept two types of functions:

- **Simple Function:** Any Python function can be exposed.
- **GT4Py Program:** Specifically, a Python function decorated with a `@program` decorator.

**Important:** All arguments in the exposed functions must use GT4Py style type hints. These are used by the parser to map GT4Py types to C and Fortran types in the generated bindings.

## Generated Files

Running `py2fgen` generates five key files:

- **.c File**: Contains the generated CFFI code and the frozen Python code.
- **.so File**: The compiled dynamic C library containing the CFFI code.
- **.h File**: Declares the function signature of your exposed function.
- **.f90 File**: Contains a Fortran interface to the C function in the dynamic library.
- **.o File**: Represents the object code of the CFFI plugin.
- (Optional) **.py File**: Contains the Python code frozen into the dynamic library (available with `--debug-mode`).

## Running from Fortran

To use the generated CFFI plugin in a Fortran program, call the subroutine defined in the `.f90` interface file. Ensure that any arrays passed to the subroutine are in column-major order.

Examples can be found under `tools/tests/py2fgen/fortran_samples`.

## Compilation

Compiling your Fortran driver code requires a Fortran compiler, such as `gfortran` or `nvfortran`. Follow these steps:

1. Compile and link the Fortran driver code along with the Fortran interface and dynamic library:

```bash
gfortran -I. -Wl,-rpath=. -L. <function_name>_plugin.f90 <fortran_driver>.f90 -l<function_name>_plugin -o <executable_name>
```

Replace `<function_name>`, `<fortran_driver>`, and `<executable_name>` with the appropriate names for your project.

**Note:** When executing the compiled binary make sure that you have sourced a Python virtual environment where all required dependencies to run the embedded Python code are present.

## Error handling

All generated Python wrapper code is wrapped in a `try: ... except: ...` block, with the wrapper function returning an error code `1` if an Exception ocurred
and `0` otherwise. In case of an exception the error message is written to the `py2f_cffi.log` file, which is located in the same directory as the generated bindings.
This means that on the Fortran side we can handle errors gracefully as follows:

```Fortran
integer(c_int) :: rc
real(c_double), dimension(:, :), allocatable :: input, result

call square(input, result, rc)

! handle the Python error here
 if (rc /= 0) then
     print *, "Python failed with exit code = ", rc
     call exit(1)
 end if
```

## Other requirements

- Embedded Python functions must have type hints for all function parameters, as these are used to derive the corresponding C and Fortran types.
- Embedded Python functions are assumed to modify function parameters in-place. Explicitly returning anything is currently not supported.
